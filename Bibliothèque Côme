(* Recherche élement liste *) 

let rec mem l e = match l with
    |[] -> false
    |e1::q -> e1 = e || mem q e;;



(* Ordre croissant? *) 

let rec croissant l = match l with
    |[] -> true
    |[e] -> true
    |e1::e2::q -> e2 >= e1 && croissant (e2::q);;



(* List.rev *) 

let rev l = 
    let rec aux acc = function
        |[] -> acc
        |e::q -> aux (e::acc) q
        in aux [] l;;
 
 
 
 (* List.map *)
 
 let rec map f = function
    |[] -> []
    |e::q -> f(e)::(map f q);;
 
 
 
 (* Fonction @ *)
 
 let rec concat l1 l2 = match l1 with
    |[] -> l2
    |e::q -> e::(concat q l2)



 (* Tri Fusion *) 
 
 let rec split = function
    |[] -> [],[]
    |[e] -> [e],[]
    |e1::e2::q -> let l1,l2 = split q in e1::l1,e2::l2;;
 
 let rec fusion l1 l2 = match l1,l2 with
    |_,[] -> l1
    |[],_ -> l2
    |e1::q1, e2::q2 when e1 < e2 -> e1::(fusion q1 l2)
    |e1::q1, e2::q2 -> e2::(fusion l1 q2)
 
 let rec tri = function
    |[] -> []
    |[e] -> [e]
    |l -> let l1,l2 = split l in fusion (tri l1) (tri l2)
 
 
 
 (* Tri Rapide *)
 
 let rec partition p = function
    |[] -> [],[]
    |e::q -> let l1, l2 = partition p q in (if e < p then e::l1,l2 else l1,e::l2)
 
 let rec quickshort = function
    |[] -> []
    |e::q -> let l1,l2 = partition e q in (quickshort l1) @ (e::quickshort l2);;   (* On utilise comme pivot le premier élement de la liste : e *)



(* Dichotomie *)

let dichotomie e t = 
    let rec aux i j = 
        let m = (i+j+1)/2 in
        if i > j 
            then false
        else
            if t.(m) = e 
                then true
            else
                if t.(m) > e 
                    then aux i (m-1)
                else
                    aux (m+1) j 
    in aux 0 ((Array.length t)-1);;
 
 
 
 (* Trichotomie *)
 
 let trichotomie e t = 
    let rec aux i j = 
        if i > j 
            then false
        else
            let m1 = (2*i + j + 1)/3 in 
            let m2 = (i + 2*j + 1)/3 in
            if t.(m1) = e || t.(m2) = e 
                then true
            else
                if t.(m1) > e 
                    then aux i (m1-1)
                else
                    if t.(m2) < e 
                        then aux (m2+1) j
                    else
                        aux (m1+1) (m2-1)
    in aux 0 (Array.length t-1);;



(* Exponentiation Rapide *)

let rec exp_rapide1 a n =
    if n = 0 
        then 1
    else 
        let b = exp_rapide a (n/2) in (* pour éviter de faire 2 appels récursifs *)
        if n mod 2 = 0 
            then b*b
        else a*b*b;;
